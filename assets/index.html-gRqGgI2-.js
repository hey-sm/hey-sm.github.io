import{_ as p,c as a,o as e,b as i}from"./app-Gl34POWz.js";const t={},s=i(`<p>上节我们写了 mini react。</p><p>它和真实的 react 渲染流程是否一样呢？</p><p>这节我们就调试下 react 源码，对比下两者的差别。</p><p>用 cra 创建个 react 项目：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>npx create-react-app --template=typescript react-source-debug</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bdad2afea154136bbcc3dce253bc5a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1118&amp;h=310&amp;s=102546&amp;e=png&amp;b=010101" alt=""></p><p>把开发服务跑起来：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>npm run start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21180866316540e7973267d54a24bcf7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&amp;h=450&amp;s=62961&amp;e=png&amp;b=181818" alt=""></p><p>浏览器访问下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe56560e7c7e483fb25a5b0e330de184~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1640&amp;h=1128&amp;s=128803&amp;e=png&amp;b=292c33" alt=""></p><p>没啥问题。</p><p>点击 create a launch.json file 创建个调试配置：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/067f7fbedd4d4cdb8a1d39adbb672638~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=654&amp;h=380&amp;s=43322&amp;e=png&amp;b=191919" alt=""></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63e97507a3784e0ebb5008421c533340~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1504&amp;h=636&amp;s=161277&amp;e=png&amp;b=1d1d1d" alt=""></p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">type</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">chrome</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">request</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">launch</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">name</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Launch Chrome against localhost</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">url</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">http://localhost:3000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">webRoot</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">\${workspaceFolder}</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 App.tsx 打个断点：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94ad5c6399e546c198d528dbe41d8f68~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1582&amp;h=912&amp;s=194923&amp;e=png&amp;b=1c1c1c" alt=""></p><p>点击调试启动：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e5002648b234f5f8b23420097fee976~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1824&amp;h=1182&amp;s=642111&amp;e=gif&amp;f=34&amp;b=191919" alt=""></p><p>代码会在这里断住。</p><p>前面讲过，jsx 会编译成 render function，然后执行后产生 React Element：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f95ad42f43846cbbd8e01da0987b76c~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><p>关掉 sorucemap 重新调试：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/462a743b321f4b6eb0fef477e4a8bd2d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1388&amp;h=624&amp;s=163264&amp;e=png&amp;b=1d1d1d" alt=""></p><p>可以看到这个 jsxDEV 就是 render function：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/838b7e519ef749bfb7f56127b074c7f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2142&amp;h=798&amp;s=339447&amp;e=png&amp;b=1e1e1e" alt=""></p><p>它是从 react 包引入的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3586bf57a9449fd8945cb3c2a87b703~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1650&amp;h=338&amp;s=141871&amp;e=png&amp;b=1f1f1f" alt=""></p><p>和我们在 babel playground 里看到的结果一样：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bbf95299c9c495f9224c30716666a52~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2180&amp;h=274&amp;s=70844&amp;e=png&amp;b=ffffff" alt=""></p><p>在这里打个断点：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b3226f3238d454d85e85111a1c5de29~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1686&amp;h=530&amp;s=153796&amp;e=png&amp;b=1f1f1f" alt=""></p><p>然后点击跳断点执行和进入函数内部：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd60b7935f614a0cb10a29526e97c243~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=506&amp;h=148&amp;s=22412&amp;e=png&amp;b=1c1c1c" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d452a2fd54b2485282aaaa6dbb7d6fb2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1824&amp;h=1182&amp;s=1742854&amp;e=gif&amp;f=35&amp;b=1d1d1d" alt=""></p><p>在返回值这里打个断点：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9609e532bcd949d0923e1a01ec1eb92e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&amp;h=676&amp;s=177008&amp;e=png&amp;b=222222" alt=""></p><p>可以看到，render function 返回的是一个 React Element，有 type、props 等属性。</p><p>我们的 mini react 里也实现了 render function：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1113e34cfbd4ba3a391943b3cf26473~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1578&amp;h=870&amp;s=143842&amp;e=png&amp;b=1f1f1f" alt=""></p><p>接下来再看 schedule 和 reconcile 部分：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87a5006344964b639654a87a37c999d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1144&amp;h=692&amp;s=217286&amp;e=png&amp;b=fefefe" alt=""></p><p>打开 sourcemap，重新跑调试：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f89e9198958b4763a7d7f12d391a92f9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1088&amp;h=638&amp;s=113070&amp;e=png&amp;b=1f1f1f" alt=""></p><p>在调用栈可以看到 workLoop：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e6c70e037ad4759a34c1b937b0a93b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2080&amp;h=1188&amp;s=423077&amp;e=png&amp;b=1c1c1c" alt=""></p><p>这个是 schduler 包里的，这个包是 react 实现的类似 requestIdleCallback 的功能。</p><p>可以看到，每次取一个任务的回调来跑：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/835df1f4e3ce48ee979fca2f9ca75252~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1458&amp;h=946&amp;s=253969&amp;e=png&amp;b=1f1f1f" alt=""></p><p>然后回调里会判断是否要用时间分片：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c6f3a7080d64d08bcfaea1a2b2fb347~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1770&amp;h=758&amp;s=329634&amp;e=png&amp;b=1e1e1e" alt=""></p><p>时间分片前面讲过，就是把 reconcile 过程分散到多个宏任务中跑：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ae6e3ebf9934b068dab509689f64b6e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1934&amp;h=638&amp;s=128766&amp;e=png&amp;b=e7d1eb" alt=""></p><p>在 scheduler 里搜一下，可以看到，这个时间分片是 5ms：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56cb5a44eecf4a919a375397e0628147~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1136&amp;h=718&amp;s=147399&amp;e=png&amp;b=1f1f1f" alt=""></p><p>也就是说，如果超过 5ms，就会放到下个任务里跑。</p><p>这就是为啥 performance 看到的 event loop 是这样的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ae6e3ebf9934b068dab509689f64b6e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1934&amp;h=638&amp;s=128766&amp;e=png&amp;b=e7d1eb" alt=""></p><p>react 并发渲染的时候，就通过时间片是否到了来判断是否继续 reconcile：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f259dcb682474ed88ffa87bfc8dec64a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=870&amp;h=256&amp;s=47973&amp;e=png&amp;b=202020" alt=""></p><p>当然，我们实现的时候没有自己实现 schduler 的时间分片，而是直接用的浏览器的 requestIdleCallback 的 api，效果一样：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e050a681cee415ea5d8c8762e67850c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1092&amp;h=754&amp;s=127865&amp;e=png&amp;b=1f1f1f" alt=""></p><p>接下来看下 reconcile 的过程：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/463e1b1a922f4422abe5f8859c029370~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1206&amp;h=1092&amp;s=284703&amp;e=png&amp;b=1f1f1f" alt=""></p><p>在 react 源码里，处理每个 fiber 节点的时候，会先调用 beginWork 处理，等 fiber 节点全部处理完，也就是没有 next 的 fiber 节点时，再调用 completeWork 处理。</p><p>那 beginWork 和 completeWork 里都做了啥呢？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d5153f63c4a400a9af63e8172a962a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1710&amp;h=1058&amp;s=415782&amp;e=png&amp;b=1d1d1d" alt=""></p><p>可以看到，根据 fiber 节点的类型来走了不同的分支，我们只处理了 FunctionComponent 和 HostComponent 类型。</p><p>看下 FunctionComponent 的处理：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1fdb0aa79a34af5a547583e449d9c59~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1400&amp;h=1164&amp;s=288380&amp;e=png&amp;b=1f1f1f" alt=""></p><p>也是调用函数组件，拿到 children 之后继续 reconcileChildren。</p><p>reconcileChildren 里要对比新旧 fiber，做下 diff，打上增删改的标记：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34ada1d184b944c1aa5769349513193b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076&amp;h=904&amp;s=158735&amp;e=png&amp;b=1f1f1f" alt=""></p><p>diff 之后，会分别打上 Place、ChildDeletion 等标记：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a72663ae7741d9ad2de9f1076e02fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=944&amp;h=870&amp;s=128295&amp;e=png&amp;b=1f1f1f" alt=""></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b4eb306a074bfea96aa31a1838a3a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=824&amp;h=560&amp;s=86377&amp;e=png&amp;b=1f1f1f" alt=""></p><p>这部分和我们 mini react 实现的 reconcile 逻辑差不多。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c54c4a281ca4ec0ac0f91d9d67862b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072&amp;h=1338&amp;s=239926&amp;e=png&amp;b=1f1f1f" alt=""></p><p>那 completeWork 是干啥的呢？</p><p>看下 HostComponent 的 reconcile 逻辑，你会发现它并没有创建 dom：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dafd4cbdd004da7ae764ed6b624b659~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1350&amp;h=1134&amp;s=336930&amp;e=png&amp;b=1f1f1f" alt=""></p><p>而我们的 mini react 里是创建了 dom 的。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d634adb6a014437586a55affaf2d70da~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922&amp;h=694&amp;s=126416&amp;e=png&amp;b=1f1f1f" alt=""></p><p>其实不是没有创建，而是这部分逻辑在 completeWork 里。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2878ca12369444c86515fd33d7d9200~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1230&amp;h=1008&amp;s=208434&amp;e=png&amp;b=1f1f1f" alt=""></p><p>completeWork 里处理到 HostComponent 就会创建对应的 dom，保存在 fiber.stateNode 属性上：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67f5e9abf25e4cb49b72135751b15bd8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1246&amp;h=1114&amp;s=264987&amp;e=png&amp;b=1f1f1f" alt=""></p><p>为什么要分为 beginWork 和 completeWork 两个阶段呢？</p><p>其实也很容易搞懂，比如创建 dom 这件事，需要先把所有子节点的 dom 都创建好，然后 appendChild 才行。</p><p>所以就需要 beginWork 处理完所有 fiber 之后，再递归从下往上处理。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97eb8e69ceff4e57abb16ef584d9e56b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1276&amp;h=504&amp;s=131585&amp;e=png&amp;b=1f1f1f" alt=""></p><p>然后是 commit 阶段，在 react 源码里可以看到，这个阶段分为了 before mutation、mutation、layout 这三个小阶段：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f9df8d9eee54d5d9daa069291c23514~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1484&amp;h=1180&amp;s=314713&amp;e=png&amp;b=1f1f1f" alt=""></p><p>mutation 阶段就是更新 dom 的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c34a56964340b99a47e66cf9356998~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1040&amp;h=650&amp;s=147405&amp;e=png&amp;b=1f1f1f" alt=""></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3264fc7e14e48208aff0ded6316e31b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=948&amp;h=554&amp;s=134639&amp;e=png&amp;b=1f1f1f" alt=""></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/259ef8eeeb844e01a6469b811b134df4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=900&amp;h=828&amp;s=147551&amp;e=png&amp;b=1f1f1f" alt=""></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e14868e89854fad92e886cf5ac8854b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=966&amp;h=808&amp;s=145327&amp;e=png&amp;b=202020" alt=""></p><p>可以看到，mutation 阶段会把 reconcile 阶段创建好的 dom 更新到 dom 树。</p><p>那啥时候执行的 effect呢？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0150ee552a2a4dc79acc0fba554e8d70~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1290&amp;h=792&amp;s=182072&amp;e=png&amp;b=1f1f1f" alt=""></p><p>刚进入 commitRoot 的时候，就会调度所有的 useEffect 的回调异步执行。</p><p>还有，useState、useEffect 等 hook 在 react 源码里是怎么实现的呢？</p><p>添加几个 hook：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a06abb1236994bfcafc2b27994c7b35c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=770&amp;h=530&amp;s=70653&amp;e=png&amp;b=1f1f1f" alt=""></p><p>在 return 那里打个断点，可以看到现在的 fiber 是这样的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a713f964199b43b09763f55a691ea96c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1540&amp;h=1070&amp;s=399136&amp;e=png&amp;b=1b1b1b" alt=""></p><p>在 fiber 上有个 memoizedState 的链表，每个节点保存一个 hook 的信息。</p><p>调用 useState、useRef、useEffect 等 hook 的时候，会往对应的链表节点上存取内容。</p><p>hook 链表的创建分为 mount、update 两个阶段，第一次创建链表节点，第二次更新链表节点。</p><p>比如 useRef 就是在对应 hook 节点的 momoizedState 属性保存一个有 current 属性的对象，第二次调用返回这个对象：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a10518722e4f01a39a0c1e79433f19~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&amp;h=606&amp;s=93621&amp;e=png&amp;b=1f1f1f" alt=""></p><p>比如 useCallback 就是在对应 hook 节点的 momoizedState 属性保存一个数组，再次调用判断下 deps 是否一样，一样的话就返回之前的数组的第一个元素，否则更新：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd1e772193dd474d8fe58897e1dcb72b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=910&amp;h=912&amp;s=185899&amp;e=png&amp;b=1f1f1f" alt=""></p><p>useMemo 和 useCallback 实现差不多，只不过保存的是函数的值：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30196458be55497bb9e36302dd54185f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&amp;h=976&amp;s=190511&amp;e=png&amp;b=1f1f1f" alt=""></p><p>这样，和 mini react 对应的 react 源码里的实现就理清了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>我们调试了下 react 源码，和前面写的 mini react 对比了下。</p><p>实现 render function 返回 React Element。</p><p>React Element 树经过 reconcile 变成 fiber 树，reconcile 的时候根据不同类型做不同处理，然后 commit 阶段执行 dom 增删改和 effect 等。</p><p>这些都差不多。</p><p>只不过 react 源码里 render 阶段 reconcile 分成了 beginWork、completeWork 两个小阶段，dom 的创建和组装是在 completeWork 里做的。</p><p>commit 阶段分成了 before mutation、mutation、layout 这三个小阶段。</p><p>react 的调度也是用自己实现的 schduler 做的，实现了时间分片，而我们用的 requestIdleCallback 做的调度。</p><p>react 的 hook 的值是存放在 fiber.memoizedState 链表上的，每个 hook 对应一个节点，在其中存取值，而我们是用的别的属性。</p><p>包括保存 dom 的节点，在 react 里是用 fiber.stateNode 属性保存。</p><p>但总体来说，流程上是差不多的，通过学习 mini react，能够很好的帮你理解 react 的实现原理。</p>`,129),m=[s];function c(n,f){return e(),a("div",null,m)}const l=p(t,[["render",c],["__file","index.html.vue"]]),r=JSON.parse(`{"path":"/notes/Web-dev/React/sqqh0b0h/","title":"第64章—手写MiniReact：和真实React源码的对比","lang":"zh-CN","frontmatter":{"title":"第64章—手写MiniReact：和真实React源码的对比","createTime":"2024/09/19 18:20:17","permalink":"/notes/Web-dev/React/sqqh0b0h/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":8.82,"words":2647},"git":{"createdTime":1726740297000,"updatedTime":1726741807000,"contributors":[{"name":"hey","email":"1760967618@qq.com","commits":3}]},"filePathRelative":"notes/Web-dev/React/第64章—手写MiniReact：和真实React源码的对比.md"}`);export{l as comp,r as data};
