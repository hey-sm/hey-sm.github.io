import{_ as p,c as e,o as a,b as c}from"./app-Gl34POWz.js";const t={},m=c('<p>我们学了如何在 VSCode 里断点调试 React 组件，也学了用 click-to-react-component 点击页面元素直接在 VSCode 打开对应组件。</p><p>这俩单独使用都很不错，而如果把两者结合起来用，会有更爽的调试体验。</p><p>比如我们要调试这个页面，理清这个输入框的内容是哪里来的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b28277d191f1499592679df67943c675~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1540&amp;h=1306&amp;s=205214&amp;e=png&amp;b=fcfcfc" alt=""></p><p>我们先在项目里引入 click-to-react-component</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e626b4145584cafb692ee1e6d86bb25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1232&amp;h=828&amp;s=180924&amp;e=png&amp;b=1f1f1f" alt=""></p><p>用它来定位这个输入框的源码在哪，按住 option + 点击元素即可：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/972cfbbb2ff44abd8c0187a32e7a2bf1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2552&amp;h=1762&amp;s=1189631&amp;e=gif&amp;f=41&amp;b=fdfcfc" alt=""></p><p>添加调试配置后启动 debug：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cc29977c3f3432fa7e7032cea348482~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2170&amp;h=702&amp;s=178418&amp;e=png&amp;b=1d1d1d" alt=""></p><p>然后在刚定位到的组件 return 的地方打个断点：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9253705cd8cc44618be9b68c9f990cb2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2148&amp;h=1470&amp;s=579776&amp;e=png&amp;b=1d1d1d" alt=""></p><p>发现这个 value 是从父组件通过 props 传进来的。</p><p>所以要继续去父组件里打断点。</p><p>但是 React 组件渲染的时候调用栈里都是 react 源码，找不到父组件在哪。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71f81ac9d8a64eeca29bb19335eba2b3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1446&amp;h=970&amp;s=295654&amp;e=png&amp;b=1b1b1b" alt=""></p><p>那怎么办呢？</p><p>这时候可以借助 click-to-react-component 展示所有父组件的能力：</p><p>按住 option + 右键，会展示这个元素所在组件的所有父组件。</p><p>点击父组件：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c885fa92d934ef79381d9e3f545a894~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2278&amp;h=1474&amp;s=1203026&amp;e=gif&amp;f=44&amp;b=fcfcfc" alt=""></p><p>这样就定位到了父组件里渲染这个子组件的源码位置：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd04a9daeea749b1bc578e63e023c1d4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1980&amp;h=1620&amp;s=648178&amp;e=png&amp;b=1d1d1d" alt=""></p><p>这时候发现这个值依然是通过 props 传进来的。</p><p>所以我们用同样的方式继续往上找：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/331e7ab81aed403eaccb848429ebf549~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2300&amp;h=1674&amp;s=1402828&amp;e=gif&amp;f=47&amp;b=fcfcfc" alt=""></p><p>定位到了一个自定义 hooks，参数都是这里返回的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b8e9ada372a40faacbc1cab7c178a9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1708&amp;h=1056&amp;s=318166&amp;e=gif&amp;f=18&amp;b=1d1d1d" alt=""></p><p>在这里打个断点调试下： <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1eedbe28a4c4099b16a97a6690320ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1814&amp;h=998&amp;s=1315018&amp;e=gif&amp;f=50&amp;b=1c1c1c" alt=""></p><p>不断 step into 进入函数内部，最终，我们找到了这个参数的来源：</p><p>在 localStorage 里读取了某个 key，key 的名字也调试出来了。</p><p>这样我们就达成了调试目标。</p><p>整个过程我们根本不需要去理清业务代码的逻辑。</p><p>想想看，你是接手这个业务项目的新人，虽然你还没看这些业务代码，但你可以快速定位界面上显示的值的来源，定位到代码在哪里改。</p><p>是不是就很高效！</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>这节我们把 VSCode 断点调试 React 组件和 click-to-react-component 点击元素在 VSCode 打开组件结合了起来。</p><p>引入 click-to-react-component，然后添加一个调试配置。</p><p>按照这样的步骤来：</p><ul><li>option + 点击页面上想调试的元素，定位到 VSCode 里的源码</li><li>打断点看一下值的来源</li><li>如果是来自父组件，那就用 option + 右键查找父组件，直接定位到父组件的源码</li><li>在定位到的父组件源码里打断点</li><li>不断往上找，直到找到产生这个值的地方，断点调试</li></ul><p>这样，就算你不懂这段业务逻辑，也能快速梳理清楚整个流程，并知道在哪里改代码。</p><p>两者结合用，调试体验是非常爽的。</p>',42),i=[m];function o(f,s){return a(),e("div",null,i)}const b=p(t,[["render",o],["__file","index.html.vue"]]),d=JSON.parse(`{"path":"/notes/Web-dev/React/4d6w2ujp/","title":"第33章—一次超爽的React调试体验","lang":"zh-CN","frontmatter":{"title":"第33章—一次超爽的React调试体验","createTime":"2024/09/19 18:20:17","permalink":"/notes/Web-dev/React/4d6w2ujp/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":3.34,"words":1003},"git":{"createdTime":1726740297000,"updatedTime":1726741807000,"contributors":[{"name":"hey","email":"1760967618@qq.com","commits":3}]},"filePathRelative":"notes/Web-dev/React/第33章—一次超爽的React调试体验.md"}`);export{b as comp,d as data};
