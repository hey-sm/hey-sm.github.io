import{_ as p,c as a,o as e,b as s}from"./app-Gl34POWz.js";const m={},c=s(`<p>大家都用过组件库，react 流行的组件库有阿里的 ant-design、字节的 semi-design、arco-design 等。</p><p>那这些组件库都是怎么打包的呢？</p><p>我们自己写个组件库的话，怎么写打包逻辑呢？</p><p>这篇文章我们就来探究下。</p><p>新建一个项目：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>mkdir component-lib-test</span></span>
<span class="line"><span></span></span>
<span class="line"><span>cd component-lib-test</span></span>
<span class="line"><span></span></span>
<span class="line"><span>npm init -y</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a80fb343ac5d41218392583cc99f115c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=894&amp;h=658&amp;s=134748&amp;e=png&amp;b=000000" alt=""></p><p>分别安装 ant-design、arco-design、semi-design</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>pnpm install antd</span></span>
<span class="line"><span></span></span>
<span class="line"><span>pnpm install @douyinfe/semi-ui</span></span>
<span class="line"><span></span></span>
<span class="line"><span>pnpm install @arco-design/web-react</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>npm、yarn 会把所有依赖铺平，看着比较乱。而 pnpm 不会，node_modules 下很清晰：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2518899cadff43fdb64faceedec43ee0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=392&amp;h=284&amp;s=23336&amp;e=png&amp;b=181818" alt=""></p><p>首先看下 antd，分为了 lib、es、dist 3 个目录：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9d31fa31d0148ff8d2598bb3c14d5a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=414&amp;h=360&amp;s=25952&amp;e=png&amp;b=191919" alt=""></p><p>分别看下这三个目录的组件代码：</p><p>lib 下的组件是 commonjs 的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f56b42587074655afebf0a555b33981~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1764&amp;h=910&amp;s=415186&amp;e=png&amp;b=1d1d1d" alt=""></p><p>es 下的组件是 es module 的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9131c1971860413a8780a8f4f125a348~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1612&amp;h=834&amp;s=313225&amp;e=png&amp;b=1d1d1d" alt=""></p><p>dist 下的组件是 umd 的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d1c9f6af12d4d0fb72ea940c1a2fca3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1780&amp;h=578&amp;s=252241&amp;e=png&amp;b=1e1e1e" alt=""></p><p>然后在 package.json 里分别声明了 commonjs、esm、umd 还有类型的入口：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd5451ec3cec426abe12b886d54f2072~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=728&amp;h=250&amp;s=45287&amp;e=png&amp;b=1f1f1f" alt=""></p><p>这样，当你用 require 引入的就是 lib 下的组件，用 import 引入的就是 es 下的组件。</p><p>而直接 script 标签引入的就是 unpkg 下的组件。</p><p>再来看看 semi-design 的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/157ebd3a769d4f72a33047fbd695ae1a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&amp;h=638&amp;s=50362&amp;e=png&amp;b=1b1b1b" alt=""></p><p>也是一样：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7715e7c48a944cf4a845ad77010ba470~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=882&amp;h=472&amp;s=84118&amp;e=png&amp;b=1f1f1f" alt=""></p><p>只不过多了个 css 目录。</p><p>antd 没有这个目录是因为它已经换成 css in js 的方案了，不需要单独引入 css 文件。</p><p>然后是 arco-design 的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5a97361868947e4b35e34d9be8522bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=516&amp;h=550&amp;s=46664&amp;e=png&amp;b=191919" alt=""></p><p>也是一样：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b6d6297540244909e19c92e61a1a30e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=686&amp;h=348&amp;s=67527&amp;e=png&amp;b=202020" alt=""></p><p>同样是 lib、es、dist 3 个目录，同样是分别声明了 esm、commonjs、umd 的入口。</p><p>也就是说，组件库都是这样的，分别打包出 3 份代码（esm、commonjs、umd），然后在 package.json 里声明不同模块规范的入口。</p><p>那问题来了，如果我有一个 esm 的模块，怎么分别构建出 esm、commonjs、umd 的 3 份代码呢？</p><p>这个问题很容易回答。</p><p>umd 的代码用 webpack 打包就行。</p><p>esm 和 commonjs 的不用打包，只需要用 tsc 或者 babel 编译下就好了。</p><p>我们分别看下这三个组件库都是怎么做的：</p><p>先是 arco-design 的：</p><p>它的构建逻辑在 arco-cli 的 arco-scripts 下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f40fa37835947739ce6310737dee358~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=592&amp;h=654&amp;s=65474&amp;e=png&amp;b=1a1a1a" alt=""></p><p>看下这个 index.ts</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/464b9ddf94e54cad8e8572f1aa04a83b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1150&amp;h=1018&amp;s=177210&amp;e=png&amp;b=1f1f1f" alt=""></p><p>分别有 build 3 种代码加上 build css 的方法。</p><p>我们分别看下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/599c297c759c44d5bbfc7f1bdd82ec3e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&amp;h=316&amp;s=50919&amp;e=png&amp;b=202020" alt=""></p><p>esm 和 cjs 的编译它封装了一个 compileTS 的方法，然后传入不同的 type。</p><p>compileTS 里可以用 tsc 或者 babel 编译：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c882faab79824713b543cac586a9a692~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1352&amp;h=350&amp;s=88518&amp;e=png&amp;b=1f1f1f" alt=""></p><p>tsc 编译就是读取项目下的 tsconfig.json，然后 compile：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/544d9ed3a99e48449c3f3618ba086a60~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&amp;h=994&amp;s=173674&amp;e=png&amp;b=1f1f1f" alt=""></p><p>babel 编译是基于内置配置，修改了下产物 modules 规范，然后编译：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9ff5c33f81b42938306db453d565c25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1134&amp;h=1194&amp;s=240360&amp;e=png&amp;b=1f1f1f" alt=""></p><p>babelConfig 里配置了 typescript 和 jsx 的编译：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe52600ebb9844798f95095e947be7b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1332&amp;h=798&amp;s=170601&amp;e=png&amp;b=1f1f1f" alt=""></p><p>再就是 umd：</p><p>和我们分析的一样，确实是用 webpack 来打包：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deabc8d5960241e38238001735c996de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=974&amp;h=324&amp;s=60006&amp;e=png&amp;b=1f1f1f" alt=""></p><p>webpack 配置里可以看到，确实是为了 unpkg 准备的，用了 ts-loader 和 babel-loader：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4c31bb57f8d46b8882385014d999469~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1164&amp;h=1132&amp;s=204949&amp;e=png&amp;b=1f1f1f" alt=""></p><p>而 css 部分则是用了 less 编译：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc6883ed9ca540a193755ad088cd9e02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&amp;h=338&amp;s=73747&amp;e=png&amp;b=1f1f1f" alt=""></p><p>gulp 是用来组织编译任务的，可以让任务串行、并行的执行。</p><p>这里的 gulp.series 就是串行执行任务，而 gulp.parallel 则是并行。</p><p>所以说，那 3 种代码加上 css 文件是怎么打包的就很清晰了：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d58b5ec46c4a7198300816482e9296~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1086&amp;h=838&amp;s=58750&amp;e=png&amp;b=ffffff" alt=""></p><p>其中用到 gulp 只是用来组织编译任务的，可用可不用。</p><p>再来看下 semi-design 的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46d142b5319b424986b46903113028ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1298&amp;h=634&amp;s=153578&amp;e=png&amp;b=1d1d1d" alt=""></p><p>它就没有单独分一个 xx-scripts 包了，直接在 semi-ui 的 scripts 目录下。</p><p>它也是用到了 gulp 来组织任务。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a98951609214496db0164e8b6e8ab50d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1040&amp;h=580&amp;s=108982&amp;e=png&amp;b=202020" alt=""></p><p>看下这个 compileLib 的 gulp task：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eed4837772aa4796ac8022d1ffa3d2c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982&amp;h=360&amp;s=50444&amp;e=png&amp;b=1f1f1f" alt=""></p><p>这里的 compileTSXForESM 和 ForCJS 很明显就是编译组件到 esm 和 cjs 两种代码的。</p><p>先用了 tsc 编译再用了 babel 编译：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a362b4f31d464986b473b03216320f0e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1290&amp;h=730&amp;s=242074&amp;e=png&amp;b=202020" alt=""></p><p>然后是 umd，也是用了 webpack：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cd9ced7af554c68aca8a33a189207f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1028&amp;h=1066&amp;s=182468&amp;e=png&amp;b=1f1f1f" alt=""></p><p>用了 babel-loader 和 ts-loader：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87ee46bf694e4e6c9b4036b981e70ab1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1272&amp;h=1284&amp;s=246860&amp;e=png&amp;b=1f1f1f" alt=""></p><p>最后是 scss 的编译：</p><p>semi-design 把所有组件的 scss 都放在了 semi-foundation 这个目录下来维护：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11215467f35a4e388189dde9d9689bbf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=528&amp;h=908&amp;s=78795&amp;e=png&amp;b=181818" alt=""></p><p>所以编译的时候就是这样的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ad183672faf44a9b1963097df6e1482~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&amp;h=878&amp;s=188823&amp;e=png&amp;b=202020" alt=""></p><p>就是把 semi-foundation 这个目录下的所有 scss 编译后合并成了一个文件</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca98599a49f64196a76d3d7303a0cf86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1062&amp;h=528&amp;s=94828&amp;e=png&amp;b=1f1f1f" alt=""></p><p>而 arco-design 的样式是在组件目录下维护的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64a91aeca77a40799523ecbff92e618e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=480&amp;h=810&amp;s=64623&amp;e=png&amp;b=1a1a1a" alt=""></p><p>这个倒是没啥大的区别，只是编译的时候改下源码目录就好了。</p><p>这就是 semi-design 的 esm、cjs、umd、scss 是如何编译打包的。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c382fd5d7ac42e48512926719eca0f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1222&amp;h=762&amp;s=60227&amp;e=png&amp;b=ffffff" alt=""></p><p>和 arco-design 的 scripts 区别大么？</p><p>不大，只不过没有单独做一个 xxx-scripts 的包，编译出 esm 和 cjs 代码用的是 tsc + babel，而且用的是 scss 不是 less 而已。</p><p>再来看看 ant-design 的：</p><p>它也是单独分了一个包来维护编译打包的 scripts，叫做 @ant-design/tools。</p><p>它也有个 gulpfile 定义了很多 task</p><p>比如 compile 的 task 是编译出 es 和 cjs 代码的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3db8648376c0448199706830821956e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1564&amp;h=670&amp;s=186991&amp;e=png&amp;b=1e1e1e" alt=""></p><p>是不是很熟悉的感觉？</p><p>大家都是这么搞的。</p><p>它也是先用了 tsc 再用 babel 编译，最后输出到 es 或者 lib 目录：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c363942819694561bacd19aad8defa25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1182&amp;h=618&amp;s=108027&amp;e=png&amp;b=1f1f1f" alt=""></p><p>打包 umd 代码的时候也是用了 webpack：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32f22bd04278441abae85cdf9cfd3cb8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1032&amp;h=522&amp;s=105861&amp;e=png&amp;b=202020" alt=""></p><p>只不过它这个 webpack 配置文件是读取的组件库项目目录下的，而不像 arco-design 那样是内置的。</p><p>这就是这三个组件库的编译打包的逻辑。</p><p>区别大么？</p><p>不大，甚至可以说几乎一模一样。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>我们分析了 ant-design、semi-design、arco-design 组件库的产物和编译打包逻辑。</p><p>它们都有 lib、es、dist 目录，分别放着 commonjs、es module、umd 规范的组件代码。</p><p>并且在 package.json 里用 main、module、unpkg 来声明了 3 种规范的入口。</p><p>从产物上来看，三个组件库都是差不多的。</p><p>然后我们分析了下编译打包的逻辑。</p><p>ant-design 和 acro-design 都是单独抽了一个放 scripts 的包，而 semi-design 没有。</p><p>它们编译 esm 和 cjs 代码都用了 babel 和 tsc 来编译，只不过 arco-design 是用 tsc 或者 babel 二选一，而 ant-design 和 semi-design 是先用 tsc 编译再用 babel 编译。</p><p>打包出 umd 的代码，三个组件库都是用的 webpack，只不过有的是把 webpack 配置内置了，有的是放在组件库项目目录下。</p><p>而样式部分，ant-design 是用 css-in-js 的运行时方案了，不需要编译，而 arco-design 用的 less，样式放组件目录下维护，semi-design 用的 scss，单独一个目录来放所有组件样式。</p><p>并且编译任务都是用的 gulp 来组织的，它可以串行、并行的执行一些任务。</p><p>虽然有一些细小的差别，但从整体上来看，这三大组件库的编译打包逻辑可以说是一模一样的。</p><p>写这样的 scripts 麻烦么？</p><p>并不麻烦，umd 部分的 webpack 打包大家都会，而 esm 和 cjs 用 babel 或者 tsc 编译也不难，至于 scss、less 部分，那个就更简单了。</p><p>所以编译打包并不是组件库的难点。</p><p>如果你要写一个组件库，也可以这样来写 scripts。</p>`,129),i=[c];function t(n,f){return e(),a("div",null,i)}const d=p(m,[["render",t],["__file","index.html.vue"]]),l=JSON.parse(`{"path":"/notes/Web-dev/React/yhqmpfqp/","title":"第39章—React组件库都是怎么构建的","lang":"zh-CN","frontmatter":{"title":"第39章—React组件库都是怎么构建的","createTime":"2024/09/19 18:20:17","permalink":"/notes/Web-dev/React/yhqmpfqp/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":8.48,"words":2544},"git":{"createdTime":1726740297000,"updatedTime":1726741807000,"contributors":[{"name":"hey","email":"1760967618@qq.com","commits":3}]},"filePathRelative":"notes/Web-dev/React/第39章—React组件库都是怎么构建的.md"}`);export{d as comp,l as data};
