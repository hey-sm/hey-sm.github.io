---
title: 10.垃圾回收与内存泄漏
author:
createTime: 2024/05/31 18:45:38
permalink: /notes/Web-dev/JavaScript/6y9lkvh3/
---
# 垃圾回收与内存泄漏

## 经典真题

- 请介绍一下 _JavaScript_ 中的垃圾回收站机制

## 什么是内存泄露

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（_runtime_）就必须供给内存。

对于持续运行的服务进程（_daemon_），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

也就是说，不再用到的内存，如果没有及时释放，就叫做内存泄漏（_memory leak_）。

## _JavaScript_ 中的垃圾回收

浏览器的 _Javascript_ 具有自动垃圾回收机制（_GC_：_Garbage Collecation_），也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。

但是这个过程不是实时的，因为其开销比较大并且 _GC_ 时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。

下面是一段示例代码：

```js
function fn1() {
	var obj = { name: 'zhangsan', age: 10 };
}
function fn2() {
	var obj = { name: 'zhangsan', age: 10 };
	return obj;
}

var a = fn1();
var b = fn2();
```

在上面的代码中，我们首先声明了两个函数，分别叫做 _fn1_ 和 _fn2_。

当 _fn1_ 被调用时，进入 _fn1_ 的环境，会开辟一块内存存放对象 _{name: 'zhangsan', age: 10}_。而当调用结束后，出了 _fn1_ 的环境，那么该块内存会被 _JavaScript_ 引擎中的垃圾回收器自动释放；

在 _fn2_ 被调用的过程中，返回的对象被全局变量 _b_ 所指向，所以该块内存并不会被释放。

这里问题就出现了：到底哪个变量是没有用的？

所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。

用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：**标记清除**和**引用计数**。

引用计数不太常用，标记清除较为常用。

## 标记清除

_JavaScript_ 中最常用的垃圾回收方式就是标记清除。

当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。

从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。

而当变量离开环境时，则将其标记为“离开环境”。

```js
function test() {
	var a = 10; // 被标记 ，进入环境
	var b = 20; // 被标记 ，进入环境
}
test(); // 执行完毕 之后 a、b 又被标离开环境，被回收。
```

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。

然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

到目前为止，_IE9+、Firefox、Opera、Chrome、Safari_ 的 _JS_ 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

## 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。

当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 _1_。如果同一个值又被赋给另一个变量，则该值的引用次数加 _1_。

相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 _1_。当这个值的引用次数变成 _0_ 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 _0_ 的值所占用的内存。

```js
function test() {
	var a = {}; // a 指向对象的引用次数为 1
	var b = a; // a 指向对象的引用次数加 1，为 2
	var c = a; // a 指向对象的引用次数再加 1，为 3
	var b = {}; // a 指向对象的引用次数减 1，为 2
}
```

_Netscape Navigator3_ 是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：**循环引用**。

循环引用指的是对象 _A_ 中包含一个指向对象 B 的指针，而对象 _B_ 中也包含一个指向对象 _A_ 的引用。

```js
function fn() {
	var a = {};
	var b = {};
	a.pro = b;
	b.pro = a;
}
fn();
```

以上代码 _a_ 和 _b_ 的引用次数都是 _2_，_fn_ 执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 _a_ 和 _b_ 的引用次数不为 _0_，所以不会被垃圾回收器回收内存，如果 _fn_ 函数被大量调用，就会造成内存泄露。在 _IE7_ 与 _IE8_ 上，内存直线上升。

## 真题解答

- 请介绍一下 _JavaScript_ 中的垃圾回收站机制

> 参考答案：
>
> _JavaScript_ 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。
>
> _JavaScript_ 常见的垃圾回收方式：**标记清除**、**引用计数**方式。
>
> 1、标记清除方式：
>
> - 工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
>
> - 工作流程：
>
> - 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；
>
> - 去掉环境中的变量以及被环境中的变量引用的变量的标记；
>
> - 被加上标记的会被视为准备删除的变量；
>
> - 垃圾回收器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。
>
> 2、引用计数方式：
>
> - 工作原理：跟踪记录每个值被引用的次数。
>
> - 工作流程：
>
> - 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 _1_；
>
> - 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 _1_；
>
> - 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 _1_；
>
> - 当引用次数变成 _0_ 时，说明没办法访问这个值了；
>
> - 当垃圾收集器下一次运行时，它就会释放引用次数是 _0_ 的值所占的内存。

-_EOF_-
